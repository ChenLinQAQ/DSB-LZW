# DSB-LZW
基于LZW算法的压缩软件，可压缩任意格式文件，但不保证压缩比小于100%QAQ
## 一、	LZW压缩技术背景
LZW压缩算法是由Abraham Lempel、Jacob Ziv和Terry Welch共同发明的一种无损压缩技术。LZW是美国Unisys公司的专利，在2003专利到期，所以现在对LZW压缩的使用已经没有限制。压缩技术的一种核心思想就是字典对照，用小的字符串代替长的字符串。压缩的思想在几千年前就已经有了，人们喜欢指代，为地名起简称是一种。在计算机则是主要用于解决通信传输问题和存储问题，Morse Code就是很好的例子。
而LZW压缩技术相对于很多压缩方法来说很大的不同是：采用定长编码，并且不存储字典，字典是在压缩和解压过程中根据之前的步骤动态生成的。相比之下Huffman编码则是需要存储字典的变长编码。如果在LZW的基础上做Huffman编码就会得到我们常见的zip格式的结果。
优缺点：一方面在最终压缩结果中不需要存储字典，并且实现起来较为简单；另一方面，对文本文件、bmp和gif等文件有较好的压缩效果，而对png、jpg等格式文件压缩比会大于100%,这是因为png等格式本身就是很好的压缩算法了。

## 二、	需求分析
1.	我们知道文件可以分为两类，文本文件和二进制文件。
<img src="https://s2.loli.net/2022/04/25/KqIxL21Zp5mUYhQ.png" >
2.	虽然两种文件有不同的表现形式，但是在计算机中它们都是以01代码的方式存储的。所以在编程方面，我们可以采用二进制的方式打开文件。用一个字节代表一个字符，取值范围是0-255，如果是ASCII文件则是0-127。所以需求中对两种文件实现压缩可以规约到同一种实现。
3.	为了提升系统的使用方便程度，所以需要实现图形用户界面，增强可交互性。界面需要提供压缩、解压接口，并且对用户可能导致的异常做出判断。
4.	核心问题是效率问题，所以压缩和解压实现采用C语言，可以手动管理内存，用来提高效率。但是C语言对图形界面支持不是很好，所以采用JAVA做图形用户界面。然后由C语言生成动态数据链接库dll文件，在JAVA中调用C语言函数。
## 三、	LZW算法原理
1.	压缩流程
<img src="https://s2.loli.net/2022/04/25/LasRZUcArxCqpzn.png" alt="_R4BYDIY.png">
2.	解压流程
<img src="https://s2.loli.net/2022/04/25/5Mwhk6flnVXyRJ3.png" >
3.	例子
A．	例子：实现对字符串 “ababcababac”的压缩。
a.	初始字典：
<img src="https://s2.loli.net/2022/04/25/51O82PBbd6tQYWE.png" alt="_R63HO4O.png">
b.	压缩流程
<img src="<img src="https://s2.loli.net/2022/04/25/51O82PBbd6tQYWE.png" alt="_R63HO4O.png">
c.	结果：0132372，压缩比：7/11 ≈ 63.6%
B．	例子：实现对字符串 “0132372”的解压缩。
a.	初始字典
 <img src="https://s2.loli.net/2022/04/25/51O82PBbd6tQYWE.png" alt="_R63HO4O.png">
b.	解压缩流程
c.结果：ababcababac
<img src="https://s2.loli.net/2022/04/25/qSIEa1wDhyAKMtG.png">
四、	LZW实现详细分析
在字典中我们可以约定，无论多长的字符串其对应的编码都是定长的，通常选择12位。12位也就决定着编码的取值范围是0-4095，也就是最多4096个编码，字典中最多存放4096个。我们还可以约定一个字符用一个字节表示，也就是8位。所以在字典中可以是1个字节对应12位，可以是2个字节对应12位，可以是3个字节对应12位......可以发现当一个字节对应12位编码的时候，压缩比会大于100%，因此我们希望尽可能多的是两个及以上的字节对应12位。
字典中的4096个编码是否就一定够用呢? 仔细想想是不可能的。如果说1MB的文件是够的，那么如果压缩1GB的文件呢？4096个编码是大概率不够用的。但是为什么选择4096呢？一方面计算机是按字节组织的，12位是一个半字节方便操作，两个12位就相当于3个字节，也就是可以说周期是2。一方面是当文件随机的话，只有长的字符串才有可能出现在字典里面的时候才有可能造成编码个数大于4096，而较长的编码出现一次再出现第二次的概率是很低的。综上，选择4096的效果是很好的。当字典编码个数大于4096的时候，就清空字典，重新开始编码，这个过程相当于对文件进行了分段，对每一段进行单独的压缩，而不同的是分割的每一段大小是不等的。
一开始我的做法：将整个文件从头到尾用一个字典进行了压缩。然后依据字典的长度，生成每一个编码的位数，再写入压缩结果。对小文件来说还是很正常的，但是当文件变大之后，字典的总数特别大，消耗了大量内存，并且需要很多位来存储字典。这样导致了最终压缩效果都特别差，压缩比远远超过100%。并且因为最终的位数可能是23、29这样周期特别大的数，对结果的写入增加了难度，我的想法是将结果首先写入到一个字符串，然后8个一次读取字符串，写入结果。这种做法有两个地方导致巨大的时间复杂度：一方面是当字符串变大的时候，在字典中查找的时候，需要进行比较，导致了更多的比较次数；一方面是字符串的频繁地拼接、截取。这种做法在压缩效果和时间、空间复杂度上都是很明显不值当的选择。
<img src="https://s2.loli.net/2022/04/25/JpcRErum2C5og8e.png" >
然后就是进一步对效率地提高：
1.	字符串之间地比较是逐个字符比较的，通过程序实现的，而基本类型之间的比较是由硬件直接完成的。所以我们尽可能地应该使用基本类型的比较，避免字符串的比较。一开始我考虑采用大数乘法、加法的方式，将字符串转换成一个对应的10进制数，这样可以将比较字符串的长度缩短为nlg2，实现之后发现大数乘法、除法的时间复杂度太高了。接着考虑采用16进制数，这样只用原来的n/4的比较长度，但是效果也不行。最终我选择采用64位基本整形(long long)，可以表示7个字符组成的字符串（不是8个的原因是，最高位是符号位，在hash函数中我们希望它大于0）。然后不对长度大于7的字符串进行编码，经过测试在字典大小位4096的情况下，很少出现大于7的情况，在BMP文件中出现的较为频繁。尽管这种做法在一定程度上提高了压缩比，但是对时间上带来了很大的改进。
2.	然后字典的存储选择了hash的方式，这是因为LZW的字典需要查找和增加操作，而Hash方式查找和增加的时间复杂度是接近O(1)的。不同的是我对链表散列的方式进行了改进，其中的每一个链表，我都替换成了AVL树。这样提高了在链表中的查找效率。这是学习JAVA中HashMap的做法，在HashMap中当链表长度大于8的时候会转换成红黑树。但是后来经过测试发现我的链表散列的模数选择了4099（质数），大多数AVL树的节点数量都是小于3的，AVL树的改进相对于链表可能没有多大的优势，所以我进行了实际测算。结果发现在向字典插入4096个单词的时候时间上的开销AVL树占有一定的优势，但是空间上AVL树处于明显的劣势，因为AVL树的节点不仅仅要存储高度，还有存储左右子、父母的指针，增大了开销。AVL树在时间上虽然没有多少节点却占有优势，但是具体分析一下，节点数量为1、2的时候AVL树退化到有序链表结构，这两者占据大多数，因此在大多数时候有序链表是不占有优势的。两种方式都做了实现，后面进行memcpy优化后（取决于空间大小），会综合考虑。
<img src="https://s2.loli.net/2022/04/25/JpcRErum2C5og8e.png" >
                                                             
                                                             
                                                             
